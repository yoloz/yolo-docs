## 切片操作

```go
// 初始化
var keys = make([]byte, len(sa))

//展开
upsql := fmt.Sprintf(ustr, m...)

// Sprintf formats according to a format specifier and returns the resulting string.
func Sprintf(format string, a ...any) string {
// ...
return ""
// 参数a 类型any,如此调用此方法的切片需要初始化为interface,即m := make([]interface{}, count)，为具体类型会错误
}

```

## java 中 byte 转换

java byte 的范围是 `-128-127`，而 golang byte 是 uint8 的别名，范围是`0-255`。

```go
func javaByteToGoByte(r rune) byte {
	if r < -128 || r > 127 {
		panic("超出byte 范围")
	}
	if r < 0 {
		return byte(256 + r)
	}
	return byte(r)
}
```

:::note
实际使用无需如此麻烦，直接`b := byte(n)`即可
:::

## 字符串操作

字符串操作在 `strings` 包

```go
strings.Index(ks, "[") == 0
strings.Split(ksr, ",")
strings.TrimSpace(sa[i])
strings.Join([]string{"hello", "world"}, "/")
strings.Replace("hello world", "l", "L", 2)
```

### 字符串与数字

操作在 `strconv` 包

```go
i, _ := strconv.Atoi("-100")
f, _ := strconv.ParseFloat("3.1415926", 64)
```

## map 操作

```go
//初始化
m := make(map[string]interface{}, 5)
//put
m [ "Google" ] = "谷歌"
m [ "Runoob" ] = "菜鸟教程"
m [ "Baidu" ] = "百度"
m [ "Wiki" ] = "维基百科"
//remove
delete(m, "Baidu")
// 遍历
for k, v := range m {
    fmt.Printf("key=%s, value=%d\n", k, v)
}
```

## list 操作

```go
// 初始化
var l list.List
// add
l.PushFront("123")
e := l.PushBack("234")
// remove
l.Remove(e)
//遍历
for i := l.Front(); i != nil; i = i.Next() {
	fmt.Println(i.Value)
}
```

## map 与 json

```go

func MapToJson(param map[string]interface{}) string{
	dataType , _ := json.Marshal(param)
	dataString := string(dataType)
	return dataString
}

func JsonToMap(str string) map[string]interface{} {
	var tempMap map[string]interface{}
	err := json.Unmarshal([]byte(str), &tempMap)
	if err != nil {
		panic(err)
	}
	return tempMap
}
```
