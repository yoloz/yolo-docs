## 加载链接文件

System.load()与 System.loadLibrary()，两个方法都是用来装载 dll 文件，不论是 JNI 库文件还是非 JNI 库文件。本地方法在被调用时都需要通过这两发方法之一将其加载至内存

### System.load(String filename)

参数为 dll 文件的绝对路径，可以是任意路径`System.load("D:\\java\\Test.dll");`

:::caution 注意

载入的库文件静态链接到其它动态链接库，如 Test.dll 静态链接到 dependency.dll。System.load() 方式：其一，相关链接文件加入到 java.library.path 的路径中，load()方法会去路径寻找依赖库；或者手动再添加 dependency.dll：

```java
//先调用
System.load("D:\\java\\dependency.dll");
//让jvm先载入dependency.dll，然后再调用
System.load("D:\\java\\Test.dll");
```

:::

### System.loadLibrary(String libname)

参数为 dll 文件名，不包含库文件的扩展名`System.loadLibrary ("Test");`，加载的文件在`java.library.path`这一 jvm 变量所指向的路径中。

:::caution 注意

loadLibrary()方式:

- 生成的链接文件需要以`lib`开头(`libxxx.so`)，否则报错：`java.lang.UnsatisfiedLinkError: no counter in java.library.`;
- 不可以在代码中写上扩展名.dll 或者.so,在 Windows 系统下加载的就是 xx.dll, 在 Linux 系统下加载的就是 xx.so;

load()方式，代码中写上文件绝对路径，文件没有需要 lib 开头要求；

:::

## JNI

参考：[在 Java 中调用 C 语言本地库](https://www.cnblogs.com/moon1992/p/5260226.html)

JNI 是 Java Native Interface 的缩写，它提供了若干的 API 实现了 Java 和其他语言的通信（主要是 C&C++）。从 Java1.1 开始，JNI 标准成为 java 平台的一部分，它允许 Java 代码和其他语言写的代码进行交互。

一旦使用 JNI, JAVA 程序就丧失了 JAVA 平台的两个优点: 程序不在跨平台。要想跨平台，必须在不同的系统环境中重新编译本地语言部分；程序不再是绝对安全的，本地代码的不当使用可能导致整个陈旭崩溃。一个通用的规则是，你应该让本地方法集中在少数几个类当中，这样就降低了 Java 语言和 C/C++之间的耦合性。

使用 JNI 实现 Java 与 C 语言混合编程的基本步骤如下：

### 编写带有 native 声明的方法的 java 类

文件名为 JNISample 的 java 代码如下:

```java
package indi.yolo.sample.jni;

import indi.yolo.sample.NativeMethodTest;

/**
 * @author yoloz
 */
public class JNISample {

     static {
        System.loadLibrary("nativemethod");
    }

    public static void main(String[] args) {

        NativeMethodTest nmt = new NativeMethodTest();

        int square = nmt.intMethod(5);
        boolean bool = nmt.booleanMethod(true);
        String text = nmt.stringMethod("java");
        int sum = nmt.intArrayMethod(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 13});

        System.out.println("intMethod: " + square);
        System.out.println("booleanMethod:" + bool);
        System.out.println("stringMethod:" + text);
        System.out.println("intArrayMethod:" + sum);
    }
}

```

文件名 NativeMethodTest 的 java 代码如下：

```java
package indi.yolo.sample.jni;

/**
 * @author yoloz
 */
public class NativeMethodTest {

    public native int intMethod(int n);

    public native boolean booleanMethod(boolean bool);

    public native String stringMethod(String text);

    public native int intArrayMethod(int[] intArray);
}


```

### 使用 javac 命令编译所有的 java 类

```bash
# 编译Java并生成完整包名路径
yoloz@debian:~/projects/xxx/sample/jni$ /opt/jdk-8/bin/javac -d . NativeMethodTest.java
yoloz@debian:~/projects/xxx/sample/jni$ /opt/jdk-8/bin/javac -d . JNISample.java

```

:::note

- 参数`-d`：这个参数是用来生成包结构的，通过 javac 命令，能够自动生成 package 目录，并且能够将 class 字节码文件放在对应目录的下面；
- 参数`.`：这个点代表当前目录，当然也可以改为其他目录；

:::

### 使用 javah 命令生成.h 文件

在命令行中运行 javah NativeMethodTest 可以生成 NativeMethodTest.h 文件(JNI-style header file)，注意不是 javah JNISample , native 关键字修饰的方法在哪个类中就使用 javah 命令生成对应的头文件。

```bash
# 生成头文件
yoloz@debian:~/projects/xxx/sample/jni$ /opt/jdk-8/bin/javah -d . indi.yolo.sample.jni.NativeMethodTest
```

文件内容如下：

```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class indi_yolo_sample_jni_NativeMethodTest */

#ifndef _Included_indi_yolo_sample_jni_NativeMethodTest
#define _Included_indi_yolo_sample_jni_NativeMethodTest
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     indi_yolo_sample_jni_NativeMethodTest
 * Method:    intMethod
 * Signature: (I)I
 */
JNIEXPORT jint JNICALL Java_indi_yolo_sample_jni_NativeMethodTest_intMethod
  (JNIEnv *, jobject, jint);

/*
 * Class:     indi_yolo_sample_jni_NativeMethodTest
 * Method:    booleanMethod
 * Signature: (Z)Z
 */
JNIEXPORT jboolean JNICALL Java_indi_yolo_sample_jni_NativeMethodTest_booleanMethod
  (JNIEnv *, jobject, jboolean);

/*
 * Class:     indi_yolo_sample_jni_NativeMethodTest
 * Method:    stringMethod
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_indi_yolo_sample_jni_NativeMethodTest_stringMethod
  (JNIEnv *, jobject, jstring);

/*
 * Class:     indi_yolo_sample_jni_NativeMethodTest
 * Method:    intArrayMethod
 * Signature: ([I)I
 */
JNIEXPORT jint JNICALL Java_indi_yolo_sample_jni_NativeMethodTest_intArrayMethod
  (JNIEnv *, jobject, jintArray);

#ifdef __cplusplus
}
#endif
#endif

```

:::info

- 头文件`jni.h`:${JDK_PATH}/include
- `jin.h`又包含了`jni_md.h`:${JDK_PATH}/include/linux

window：${JDK_PATH}/include/win32

- 函数名格式：`Java_包名_类名_Java方法名`，将包名中的`.`换成`_`;
- 注释中 Signature：这个是方法的签名：

| java 类型 | Signature                | 说明                                                                         |
| --------- | ------------------------ | ---------------------------------------------------------------------------- |
| boolean   | Z                        |
| byte      | B                        |
| char      | C                        |
| short     | S                        |
| int       | I                        |
| long      | L                        |
| float     | F                        |
| double    | D                        |
| void      | V                        |
| Object    | `L用/分割的完整类名`     | 例如: `Ljava/lang/String`：表示 String 类型                                  |
| Array     | `[签名`                  | 例如:`[I`：表示 int 类型的数组, `[Ljava/lang/String`：表示 String 类型的数组 |
| Method    | `(参数签名)返回类型签名` | 例如: `([I)I`：表示参数类型为 int 数组，返回值 int 类型的方法                |

- `JNIEnv *`:表示 JNI 环境，该环境封装了所有 JNI 的操作函数, 使用起来类似 Java 的反射, 常用其编码转换的函数；
- jobject：java 代码中调用该 C 函数的对象

:::

### 使用 C/C++实现本地方法

可以使用 C 语言来实现, 也可以使用 C++来实现, 下面说说 C 语言的实现(nativemethod.c)：

```c
#include "indi_yolo_sample_jni_NativeMethodTest.h"
#include <string.h>

void my_strupr(char str[])
{
    int nNum;
    nNum = strlen(str);
    for (int i = 0; i < nNum; i++)
    {
        if (str[i] >= 'a' && str[i] <= 'z')
        {
            str[i] -= 32;
        }
    }
}

JNIEXPORT jint JNICALL Java_indi_yolo_sample_jni_NativeMethodTest_intMethod(JNIEnv *env, jobject obj, jint i)
{
    return i * i;
}

JNIEXPORT jboolean JNICALL Java_indi_yolo_sample_jni_NativeMethodTest_booleanMethod(JNIEnv *env, jobject obj, jboolean b)
{
    return !b;
}

JNIEXPORT jstring JNICALL Java_indi_yolo_sample_jni_NativeMethodTest_stringMethod(JNIEnv *env, jobject obj, jstring string)
{
    const char *str = (*env)->GetStringUTFChars(env, string, 0);
    char cap[128];
    strcpy(cap, str);
    (*env)->ReleaseStringUTFChars(env, string, 0);
    //    strupr:将字符串s转换为大写形式,不是标准C库函数，只能在window(VC,MinGW)中使用,在linux gcc环境下需要自行定义这个函数。
    // return (*env)->NewStringUTF(env, strupr(cap));
    my_strupr(cap);
    return (*env)->NewStringUTF(env, cap);
}

JNIEXPORT jint JNICALL Java_indi_yolo_sample_jni_NativeMethodTest_intArrayMethod(JNIEnv *env, jobject obj, jintArray array)
{
    int i, sum = 0;
    jsize len = (*env)->GetArrayLength(env, array);
    jint *body = (*env)->GetIntArrayElements(env, array, 0);

    for (i = 0; i < len; i++)
    {
        sum += body[i];
    }
    (*env)->ReleaseIntArrayElements(env, array, body, 0);
    return sum;
}
```

:::info

- `(*env)->GetStringUTFChars()`:用来在 Java 和 C 之间转换字符串的, 因为 Java 本身都使用了双字节的字符, 而 C 语言本身都是单字节的字符, 所以需要进行转换;
- GetStringUTFChars()和 NewStringUTF(), 第一个是从 UTF-8 转换为 C 的编码格式, 第二个是根据 C 的字符串返回一个 UTF8 字符串;
- ReleaseStringUTFChars()是用来释放对象的, 在 Java 中有虚拟机进行垃圾回收, 但是在 C 语言中, 这些对象必须手动回收. 否则可能造成内存泄漏;

:::

### 将 C/C++编写的文件生成动态链接库并调用

```bash
# 生成动态链接库,使用loadLibrary方式，故生成文件为libxxx.so
yoloz@debian:~/projects/xxx/sample/jni$ gcc -shared -fPIC -I /opt/jdk-8/include/ -I /opt/jdk-8/include/linux/  -o libnativemethod.so nativemethod.c
# 运行Java，并指定动态链接库的路径
yoloz@debian:~/projects/xxx/sample/jni$ /opt/jdk-8/bin/java -Djava.library.path=. indi.yolo.sample.jni.JNISample
```

## JNA

参考：[调用本地方法的利器 JNA](https://juejin.cn/post/7073051794359713805)

JAVA 是可以调用本地方法的，官方提供的调用方式叫做 JNI，全称叫做 java native interface。要想使用 JNI，我们需要在 JAVA 代码中定义 native 方法，然后通过 javah 命令创建 C 语言的头文件，接着使用 C 或者 C++语言来实现这个头文件中的方法，编译源代码，最后将编译后的文件引入到 JAVA 的 classpath 中运行。

> JNA provides Java programs easy access to native shared libraries without writing anything but Java code - no JNI or native code is required.

JNA 的全称是 Java Native Access,它为我们提供了一种更加简单的方式来访问本地的共享库资源，如果你使用 JNA，那么你只需要编写相应的 java 代码即可，不需要编写 JNI 或者本地代码,非常的方便。

JNA 就是一个 jar 包：

```xml
<dependency>
    <groupId>net.java.dev.jna</groupId>
    <artifactId>jna</artifactId>
    <version>5.13.0</version>
</dependency>
```

jar 包里面除了包含有基本的 JAVA class 文件之外，还有很多和平台相关的文件，这些平台相关的文件夹下面都是 libjnidispatch\*的库文件。JNA 的本质就是将大多数 native 的方法封装到 jar 包中的动态库中，并且提供了一系列的机制来自动加载这个动态库。

类型对应关系：

| Native Type     | Java Type             | Native Representation         |
| --------------- | --------------------- | ----------------------------- |
| char            | byte                  | 8-bit integer                 |
| wchar_t         | char                  | 16/32-bit character           |
| short           | short                 | 16-bit integer                |
| int             | int                   | 32-bit integer                |
| int             | boolean               | 32-bit integer (customizable) |
| long, `__int64` | long                  | 64-bit integer                |
| long long       | long                  | 64-bit integer                |
| float           | float                 | 32-bit FP                     |
| double          | double                | 64-bit FP                     |
| `char*`         | String                |
| `wchar_t*`      | WString               |
| `char**`        | String[]              |
| `wchar_t**`     | WString[]             |
| `void*`         | Pointer               |
| `void **`       | PointerByReference    |
| `int&`          | IntByReference        |
| `int*`          | IntByReference，int[] |
| struct          | Structure             |
| `(*fp)()`       | Callback              |
| varies          | NativeMapped          |
| long            | NativeLong            |
| pointer         | PointerType           |

:::info JNI 加载 native lib
在 JNI 中，我们首先在 java 代码中定义要调用的 native 方法，然后使用 javah 命令，创建 C 的头文件，然后再使用 C 或者 C++来对这个头文件进行实现。

接下来最重要的一步就是将生成的动态链接库添加到 JAVA 的 classpath 中，从而在 JAVA 调用 native 方法的时候，能够加载到对应的库文件。

:::

JNA 加载 native lib 的流程如下：

### 确认本地文件及调用函数

已经存在本地文件(dll 或 so),这里手动创建 nativemethod.c:

```c
#include <string.h>
#include<assert.h>

int intMethod(int i)
{
    return i * i;
}

int booleanMethod(int b)
{
    return b > 0 ? 1 : 0;
}

char *stringMethod(char *str)
{
    assert(str);         // str的非空性
    char *ret = str;     // 定义一个ret保存最初的str
    while (*str != '\0') // 判断字符串是否结束
    {
        if ((*str >= 'a') && (*str <= 'z')) // 判断当前的字符是否是小写字母
        {
            *str = *str - 32; // 将其转化为大写字母
            str++;
        }
        else
        {
            str++;
        }
    }
    return ret; // 返回该字符串数组的首地址
}

int intArrayMethod(int *array)
{
    int i, sum = 0;
    int len = sizeof(array);
    for (i = 0; i < len + 1; i++)
    {
        sum += array[i];
    }
    // free(array);
    return sum;
}
```

生成本地文件：

```bash
#
yoloz@debian:~/projects/xxx/sample/jna$ gcc -shared -fPIC -o libnativemethod.so nativemethod.c
```

### 编写调用本地函数的 java 代码

创建调用本地函数的 java 文件(JNASample.java):

```java
package indi.yolo.sample.jna;

import com.sun.jna.Library;
import com.sun.jna.Native;

/**
 * @author yoloz
 */
public class JNASample {

    public interface CLibrary extends Library {

        //CLibrary INSTANCE = Native.load((Platform.isWindows() ? "msvcrt" : "c"), CLibrary.class);
        //加载nativemethod，并使用其中的函数
        CLibrary INSTANCE = Native.load("nativemethod", CLibrary.class);

        int intMethod(int n);

        boolean booleanMethod(boolean bool);

        String stringMethod(String text);

        int intArrayMethod(int[] intArray);
    }

    public static void main(String[] args) {
        CLibrary cLibrary = CLibrary.INSTANCE;
        int square = cLibrary.intMethod(5);
        boolean bool = cLibrary.booleanMethod(true);
        String text = cLibrary.stringMethod("java");
        int sum = cLibrary.intArrayMethod(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 13});

        System.out.println("intMethod: " + square);
        System.out.println("booleanMethod:" + bool);
        System.out.println("stringMethod:" + text);
        System.out.println("intArrayMethod:" + sum);
    }

}

```

### 编译运行

```bash
yoloz@debian:~/projects/xxx/sample/jna$ /opt/jdk-8/bin/javac -cp /xxx/jna-5.13.0.jar -d . JNASample.java
# 添加JVM参数：-Djna.debug_load=true输出详情
yoloz@debian:~/projects/xxx/sample/jna$ /opt/jdk-8/bin/java -cp /xxx/5.13.0/jna-5.13.0.jar:. -Djava.library.path=. indi.yolo.sample.jna.JNASample
```

## java.lang.UnsatisfiedLinkError

```log
PS C:\java> .\jre1.8.0_361\bin\java.exe -cp ".;.\jna-5.13.0.jar" indi.yolo.sample.jna.JNAGoSample
Exception in thread "main" java.lang.UnsatisfiedLinkError: Unable to load library 'C:\java\libtest.dll':
%1 不是有效的 Win32 应用程序。

%1 不是有效的 Win32 应用程序。
Native library (win32-x86-64/C:\java\libtest.dll) not found in resource path ([file:/C:/java/, file:/C:/java/jna-5.13.0.jar])
        at com.sun.jna.NativeLibrary.loadLibrary(NativeLibrary.java:323)
        at com.sun.jna.NativeLibrary.getInstance(NativeLibrary.java:483)
        at com.sun.jna.Library$Handler.<init>(Library.java:197)
        at com.sun.jna.Native.load(Native.java:622)
        at com.sun.jna.Native.load(Native.java:596)
        at indi.yolo.sample.jna.JNAGoSample$CLibrary.<clinit>(JNAGoSample.java:13)
        at indi.yolo.sample.jna.JNAGoSample.main(JNAGoSample.java:31)
        Suppressed: java.lang.UnsatisfiedLinkError: %1 不是有效的 Win32 应用程序。

                at com.sun.jna.Native.open(Native Method)
                at com.sun.jna.NativeLibrary.loadLibrary(NativeLibrary.java:211)
                ... 6 more
        Suppressed: java.lang.UnsatisfiedLinkError: %1 不是有效的 Win32 应用程序。

                at com.sun.jna.Native.open(Native Method)
                at com.sun.jna.NativeLibrary.loadLibrary(NativeLibrary.java:224)
                ... 6 more
        Suppressed: java.io.IOException: Native library (win32-x86-64/C:\java\libtest.dll) not found in resource path ([file:/C:/java/, file:/C:/java/jna-5.13.0.jar])
                at com.sun.jna.Native.extractFromResourcePath(Native.java:1145)
                at com.sun.jna.NativeLibrary.loadLibrary(NativeLibrary.java:295)
                ... 6 more
```

主要是 3 种原因：

- 本地文件没有放置到 classpath；
- 本地文件版本与 jdk 版本不一致，如 dll、so 为 32 位，jdk 为 64 位；
- 本地文件依赖的其它库不存在，如 so 依赖的其它 so 不存在，则 so 本身就不能运行，自然会报错；
  - 判断 dll 是否依赖其它 dll，可以使用工具或向系统中注册 dll，能注册成功即是 dll 依赖正常。
  - 判断 so 是否依赖其它 so，使用 ldd 命令，如果有缺失，会出现 xx.so not found 字样。

此处错误在`libtest.dll`在 linux 中生成，在 window 中安装 mingw64 后编译生成 libtest.dll 即可使用。
