## 起因

在海量用户高并发访问的大型网站后台，有一些基本的系统维护需求。比如迁移海量小文件，就是从一些机器拷贝海量小碎文件到另一些机器，来完成一些系统维护的基本需求。

## 避免慢启动

### 什么是慢启动

最初的 TCP 的实现方式是，在连接建立成功后便会向网络中发送大尺寸的数据包，假如网络出现问题，很多这样的大包会积攒在路由器上，很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此现在的 TCP 协议规定了，新建立的连接不能够一开始就发送大尺寸的数据包，而只能从一个小尺寸的包开始发送，在发送和数据被对方确认的过程中去计算对方的接收速度，来逐步增加每次发送的数据量（最后到达一个稳定的值，进入高速传输阶段。相应的，慢启动过程中，TCP 通道处在低速传输阶段），以避免上述现象的发生。这个策略就是慢启动。画个简单的图从原理上粗略描述一下

![smallfiletransfer.jpg](/docs/network/smallfiletransfer.jpg)

### 慢启动引起的性能问题

慢启动为什么会对拷贝海量小文件的需求造成重大性能损失？

举个简单的例子，我们对每个文件都采用独立的 TCP 连接来传输（循环使用 scp 拷贝就是这个例子的实际场景，很常见的用法）。那么工作过程应该是，每传输一个文件建立一个连接，然后连接处于慢启动阶段，传输小文件，每个小文件几乎都处于独立连接的慢启动阶段被传输，这样传输过程所用的 TCP 包的总量就会增多。更细致的说一说这个事，如果在慢启动过程中传输一个小文件，我们可能需要 2 至 3 个小包，而在一个已经完成慢启动的 TCP 通道中（TCP 通道已进入在高速传输阶段），我们传输这个文件可能只需要 1 个大包。网络拷贝文件的时间基本上全部消耗都在网络传输的过程中（发数据过去等对端 ACK，ACK 确认归来继续再发，这样的数据来回交互相比较本机的文件读写非常耗时间），撇开三次握手和四次握手那些包，粗略来说，慢启动阶段传输这些文件所用的包的数目是高速通道传输这些文件的包的数目的 2-3 倍！那么时间上应该也是 2-3 倍的关系！如果文件的量足够大，这个总时间就会被放大到需求难以忍受的地步。

因此，在迁移海量小文件的需求下，我们不能使用“对每个文件都采用独立的 TCP 连接来传输（循环使用 scp 拷贝）“这样的策略，它会使每个文件的传输都处于在一个独立 TCP 的慢启动阶段。

### 如何避免慢启动

很简单，尽量把大量小文件放在一个 TCP 连接中排队传输。起初的一两个文件处于慢启动过程传输，后续的文件传输全部处于高速通道中传输，用这样的方式来减少发包的数目，进而降低时间消耗。

题外话，实际上这种传输策略带来的性能提升的功劳不仅仅归于避免慢启动，事实上也避免了大量的 3 次握手和四次握手，这个对海量小文件传输的性能消耗也非常致命。

随着多核服务器的兴起，以及现代网卡的多通道技术的迅猛发展，现在我们解决这一问题的通常做法是绑定多 CPU 的多核到网卡的多个通道，然后由 CPU 的核来均分传输这些小文件，每个核用一个 TCP 连接来排队发送分到的小文件。

讲到这儿，我想大家对于大文件的传输策略应该也心里有数了，（不考虑网卡带宽的前提下）就是分块传输，在目标机器合并。

## 避免大量握手

### 多次握手引起的性能问题

大量握手为什么会对拷贝海量小文件的需求造成重大性能损失？

举个简单的例子，我们对每个文件都采用独立的 TCP 连接来传输（循环使用 scp 拷贝就是这个例子的实际场景，很常见的用法）。那么工作过程应该是，每传输一个文件建立一个连接，三次握手连接，传输小文件（也许只是 1 至 2 个 TCP 包，我们在这先假定一个包就能传完这个小文件），四次握手断开。朋友们可以算一算，假设传输一个小文件只需要一个 TCP 数据包和一个 ACK 包，那么在这样的传输策略之下，为了传输这一个数据包，需要额外的七个包来为这 2 个包服务。性能消耗比是 2:7（三次握手请求和四次握手断开）

### 如何避免握手

尽量把大量小文件放在一个 TCP 连接中排队传输。一次性建立连接，逐步经过慢启动，后续的文件传输全部处于高速通道中传输，用这样的方式来彻底避免多次握手对性能的消耗，进而提升性能。

实际上这种传输策略带来的性能提升不仅仅归功于避免了多次握手，事实上也避免了大量的慢启动，这个对海量小文件传输的性能消耗也非常致命。

随着多核服务器的兴起，以及现代网卡的多通道技术的迅猛发展，现在我们解决这一问题的通常做法是绑定多 CPU 的多核到网卡的多个通道，然后由 CPU 的核来均分传输这些小文件，每个核用一个 TCP 连接来排队发送分到的小文件。
