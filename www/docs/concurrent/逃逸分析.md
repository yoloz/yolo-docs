## 定义

逃逸分析的是一个对象的动态作用域，两种情况：

1. 方法逃逸：对象通过参数传递传给了另一个方法
2. 线程逃逸：对象有另外的线程访问

逃逸分析的目的是确认一个对象是否只可能当前线程能访问

## 应用

如果对象分析后不能发生逃逸，如方法中创建的临时对象，则 JVM 可进行如下优化：

1. 栈上分配

在栈上分配对象，应该只有当前线程使用，随方法的退出自动销毁，提升性能

2. 标量替换

所谓标量就是不能再分割的变量。如 Java 基本数据类型
如果用到对象的标量，可以不分配对象，改为创建单独的标量放入栈或寄存器中。

3. 锁消除

因为只有当前线程使用，所以对此对象的锁操作可以优化去除

## 逃逸分析开关

Java8 逃逸分析默认是打开的，也可通过开关控制

```
-XX:+DoEscapeAnalysis开启逃逸分析
-XX:-DoEscapeAnalysis 关闭逃逸分析

-XX:+EliminateAllocations开启标量替换
-XX:-EliminateAllocations 关闭标量替换

-XX:+EliminateLocks开启锁消除（jdk1.8默认开启，其它版本未测试）
-XX:-EliminateLocks 关闭锁消除
（开启标量替换或锁消除 必须打开逃逸分析开关）
```

## 栈上分配

逃逸开关开启，且确认对象不发生逃逸，也并非所有的对象全是栈上分配的
首先逃逸分析是依赖 JIT 即时编译的，而触发 JIT 必须是热点代码，Server 模式默认至少 10000 次方法执行才认为此方法是热点方法
从这个角度看，那一开始所有的对象还是在堆中分配。当前哪个分配是一个复杂的分析过程，我们要只要这回事即可（栈上分配不是绝对的）

[来源](https://www.nps.ink/329647.html)
