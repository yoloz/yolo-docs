字节码增强技术就是一类对现有字节码进行修改或者动态生成全新字节码文件的技术。

从生命周期角度看:

![aop1.png](/docs/jvm/aop1.png)

直接操纵字节码的实现方式:

![aop2.png](/docs/jvm/aop2.png)

## 静态代理

静态代理是最简单也是最容易理解的一种方式，只需要在编码的时候手动创建代理类调用即可，缺点也很明显，灵活性太差，代理的代码很难复用，编码结束之后类的增强就没有补充的可能性了。

```java
// 接口
public interface NameService {
    void printName(String name);
}
// 实现类
public class NameServiceImpl implements NameService {
    @Override
    public void printName(String name) {
        System.out.println(name);
        try {
            Thread.sleep(1000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
// 代理类
public class NameServiceProxy implements NameService {

    private NameService target;

    public NameServiceProxy(NameService nameService){
        this.target = nameService;
    }

    @Override
    public void printName(String name) {
        long cost = System.currentTimeMillis();
        target.printName(name);
        cost = System.currentTimeMillis() - cost;
        System.out.println("method printName cost is "+ cost);
    }
}
// 调用
public class Main {

    public static void main(String[] args) throws Exception {
        NameService nameService = new NameServiceProxy(new NameServiceImpl());
        nameService.printName("tiang");
    }
}
/**结果
tiang
method printName cost is 1002
**/
```

## AspectJ

```java
//服务编码
public class NameService {
    public void printName(String name){
        System.out.println(name);
        try {
            Thread.sleep(1000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

编写切面文件 WasteTime.aj：

```txt
public aspect WasteTime {

    pointcut print():execution(void NameService.printName(..));

    void around(): print(){
        long cost = System.currentTimeMillis();
        proceed();
        cost = System.currentTimeMillis() - cost;
        System.out.println("method printName cost :" + cost);
    }
}
```

```java
//采用AspectJ编译器编译后执行
public class Main {
    public static void main(String[] args) {
        NameService nameService = new NameService();
        nameService.printName("tiang");
    }
}
/**结果
tiang
method printName cost :1000
**/
```

将编译后的 NamService.class 文件进行反编译:

```java
public class NameService
{
    public void printName(final String name) {
        printName_aroundBody1$advice(this, name, WasteTime.aspectOf(), null);
    }
    // 原方法
    private static final /* synthetic */ void printName_aroundBody0(final NameService ajc$this, final String name) {
        System.out.println(name);
        try {
            Thread.sleep(1000L);
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    // 增强的代码与原方法耦合
    private static final /* synthetic */ void printName_aroundBody1$advice(final NameService ajc$this, final String name, final WasteTime ajc$aspectInstance, final AroundClosure ajc$aroundClosure) {
        long cost = System.currentTimeMillis();
        printName_aroundBody0(ajc$this, name);
        cost = System.currentTimeMillis() - cost;
        System.out.println("method printName cost :" + cost);
    }
}
```

从反编译之后的结果可以看出，增强的部分代码被直接编译整合进了原有类的代码中。顺便一提的是，aspectJ 除了支持自定义的.aj 文件进行切面之外，还支持直接使用 java 代码通过注解@Before、@Around 等进行编码，这一点也被后来的 spring 所借鉴。

## ASM

对于需要手动操纵字节码的需求，可以使用 ASM，它可以直接生产 .class 字节码文件，也可以在类被加载入 JVM 之前动态修改类行为（如下图 17 所示）。ASM 的应用场景有 AOP（Cglib 就是基于 ASM）、热部署、修改其他 jar 包中的类等。当然，涉及到如此底层的步骤，实现起来也比较麻烦。接下来，本文将介绍 ASM 的两种 API，并用 ASM 来实现一个比较粗糙的 AOP。但在此之前，为了让大家更快地理解 ASM 的处理流程，强烈建议读者先对访问者模式进行了解。简单来说，访问者模式主要用于修改或操作一些数据结构比较稳定的数据，而通过第一章，我们知道字节码文件的结构是由 JVM 固定的，所以很适合利用访问者模式对字节码文件进行修改。

![asm1.png](/docs/jvm/asm1.png)
图 17 ASM 修改字节码

### ASM API

1. 核心 API

ASM Core API 可以类比解析 XML 文件中的 SAX 方式，不需要把这个类的整个结构读取进来，就可以用流式的方法来处理字节码文件。好处是非常节约内存，但是编程难度较大。然而出于性能考虑，一般情况下编程都使用 Core API。在 Core API 中有以下几个关键类：

- ClassReader：用于读取已经编译好的.class 文件。
- ClassWriter：用于重新构建编译后的类，如修改类名、属性以及方法，也可以生成新的类的字节码文件。
- 各种 Visitor 类：如上所述，CoreAPI 根据字节码从上到下依次处理，对于字节码文件中不同的区域有不同的 Visitor，比如用于访问方法的 MethodVisitor、用于访问类变量的 FieldVisitor、用于访问注解的 AnnotationVisitor 等。为了实现 AOP，重点要使用的是 MethodVisitor。

2. 树形 API

ASM Tree API 可以类比解析 XML 文件中的 DOM 方式，把整个类的结构读取到内存中，缺点是消耗内存多，但是编程比较简单。TreeApi 不同于 CoreAPI，TreeAPI 通过各种 Node 类来映射字节码的各个区域，类比 DOM 节点，就可以很好地理解这种编程方式。

### 直接利用 ASM 实现 AOP

利用 ASM 的 CoreAPI 来增强类。这里不纠结于 AOP 的专业名词如切片、通知，只实现在方法调用前、后增加逻辑，通俗易懂且方便理解。首先定义需要被增强的 Base 类：其中只包含一个 process()方法，方法内输出一行“process”。增强后，我们期望的是，方法执行前输出“start”，之后输出"end"。

```java
public class Base {
    public void process(){
        System.out.println("process");
    }
}
```

为了利用 ASM 实现 AOP，需要定义两个类：一个是 MyClassVisitor 类，用于对字节码的 visit 以及修改；另一个是 Generator 类，在这个类中定义 ClassReader 和 ClassWriter，其中的逻辑是，classReader 读取字节码，然后交给 MyClassVisitor 类处理，处理完成后由 ClassWriter 写字节码并将旧的字节码替换掉。Generator 类较简单，我们先看一下它的实现，如下所示，然后重点解释 MyClassVisitor 类。

```java
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassWriter;

public class Generator {
    public static void main(String[] args) throws Exception {
                //读取
        ClassReader classReader = new ClassReader("meituan/bytecode/asm/Base");
        ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);
        //处理
        ClassVisitor classVisitor = new MyClassVisitor(classWriter);
        classReader.accept(classVisitor, ClassReader.SKIP_DEBUG);
        byte[] data = classWriter.toByteArray();
        //输出
        File f = new File("operation-server/target/classes/meituan/bytecode/asm/Base.class");
        FileOutputStream fout = new FileOutputStream(f);
        fout.write(data);
        fout.close();
        System.out.println("now generator cc success!!!!!");
    }
}
```

MyClassVisitor 继承自 ClassVisitor，用于对字节码的观察。它还包含一个内部类 MyMethodVisitor，继承自 MethodVisitor 用于对类内方法的观察，它的整体代码如下：

```java
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

public class MyClassVisitor extends ClassVisitor implements Opcodes {
    public MyClassVisitor(ClassVisitor cv) {
        super(ASM5, cv);
    }
    @Override
    public void visit(int version, int access, String name, String signature,
                      String superName, String[] interfaces) {
        cv.visit(version, access, name, signature, superName, interfaces);
    }
    @Override
    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
        MethodVisitor mv = cv.visitMethod(access, name, desc, signature,
                exceptions);
        //Base类中有两个方法：无参构造以及process方法，这里不增强构造方法
        if (!name.equals("<init>") && mv != null) {
            mv = new MyMethodVisitor(mv);
        }
        return mv;
    }
    class MyMethodVisitor extends MethodVisitor implements Opcodes {
        public MyMethodVisitor(MethodVisitor mv) {
            super(Opcodes.ASM5, mv);
        }

        @Override
        public void visitCode() {
            super.visitCode();
            mv.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");
            mv.visitLdcInsn("start");
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);
        }
        @Override
        public void visitInsn(int opcode) {
            if ((opcode >= Opcodes.IRETURN && opcode <= Opcodes.RETURN)
                    || opcode == Opcodes.ATHROW) {
                //方法在返回之前，打印"end"
                mv.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");
                mv.visitLdcInsn("end");
                mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);
            }
            mv.visitInsn(opcode);
        }
    }
}
```

利用这个类就可以实现对字节码的修改。详细解读其中的代码，对字节码做修改的步骤是：

- 首先通过 MyClassVisitor 类中的 visitMethod 方法，判断当前字节码读到哪一个方法了。跳过构造方法`<init>`后，将需要被增强的方法交给内部类 MyMethodVisitor 来进行处理；
- 接下来，进入内部类 MyMethodVisitor 中的 visitCode 方法，它会在 ASM 开始访问某一个方法的 Code 区时被调用，重写 visitCode 方法，将 AOP 中的前置逻辑就放在这里；
- MyMethodVisitor 继续读取字节码指令，每当 ASM 访问到无参数指令时，都会调用 MyMethodVisitor 中的 visitInsn 方法。我们判断了当前指令是否为无参数的“return”指令，如果是就在它的前面添加一些指令，也就是将 AOP 的后置逻辑放在该方法中;
- 综上，重写 MyMethodVisitor 中的两个方法，就可以实现 AOP 了，而重写方法时就需要用 ASM 的写法，手动写入或者修改字节码。通过调用 methodVisitor 的 visitXXXXInsn()方法就可以实现字节码的插入，XXXX 对应相应的操作码助记符类型，比如 mv.visitLdcInsn("end")对应的操作码就是 ldc "end"，即将字符串“end”压入栈;

完成这两个 visitor 类后，运行 Generator 中的 main 方法完成对 Base 类的字节码增强，增强后的结果可以在编译后的 target 文件夹中找到 Base.class 文件进行查看，可以看到反编译后的代码已经改变了（如图 18 左侧所示）。然后写一个测试类 MyTest，在其中 new Base()，并调用 base.process()方法，可以看到下图右侧所示的 AOP 实现效果：

![asm2.png](/docs/jvm/asm2.png)
图 18 ASM 实现 AOP 的效果

### ASM 工具

利用 ASM 手写字节码时，需要利用一系列 visitXXXXInsn()方法来写对应的助记符，所以需要先将每一行源代码转化为一个个的助记符，然后通过 ASM 的语法转换为 visitXXXXInsn()这种写法。第一步将源码转化为助记符就已经够麻烦了，不熟悉字节码操作集合的话，需要我们将代码编译后再反编译，才能得到源代码对应的助记符。第二步利用 ASM 写字节码时，如何传参也很令人头疼。ASM 社区也知道这两个问题，所以提供了工具[ASM ByteCode Outline](https://plugins.jetbrains.com/plugin/5918-asm-bytecode-outline)。

安装后，右键选择“Show Bytecode Outline”，在新标签页中选择“ASMified”这个 tab，如图 19 所示，就可以看到这个类中的代码对应的 ASM 写法了。图中上下两个红框分别对应 AOP 中的前置逻辑于后置逻辑，将这两块直接复制到 visitor 中的 visitMethod()以及 visitInsn()方法中，就可以了。

![asm3.png](/docs/jvm/asm3.png)
图 19 ASM Bytecode Outline

## Javassist

ASM 是在指令层次上操作字节码的，阅读上文后，我们的直观感受是在指令层次上操作字节码的框架实现起来比较晦涩。故除此之外，我们再简单介绍另外一类框架：强调源代码层次操作字节码的框架 Javassist。

利用 Javassist 实现字节码增强时，可以无须关注字节码刻板的结构，其优点就在于编程简单。直接使用 java 编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构或者动态生成类。其中最重要的是 ClassPool、CtClass、CtMethod、CtField 这四个类：

- CtClass（compile-time class）：编译时类信息，它是一个 class 文件在代码中的抽象表现形式，可以通过一个类的全限定名来获取一个 CtClass 对象，用来表示这个类文件。
- ClassPool：从开发视角来看，ClassPool 是一张保存 CtClass 信息的 HashTable，key 为类名，value 为类名对应的 CtClass 对象。当我们需要对某个类进行修改时，就是通过 pool.getCtClass("className")方法从 pool 中获取到相应的 CtClass。
- CtMethod、CtField：这两个比较好理解，对应的是类中的方法和属性。

了解这四个类后，我们可以写一个小 Demo 来展示 Javassist 简单、快速的特点。我们依然是对 Base 中的 process()方法做增强，在方法调用前后分别输出"start"和"end"，实现代码如下。我们需要做的就是从 pool 中获取到相应的 CtClass 对象和其中的方法，然后执行 method.insertBefore 和 insertAfter 方法，参数为要插入的 Java 代码，再以字符串的形式传入即可，实现起来也极为简单。

```java
import com.meituan.mtrace.agent.javassist.*;

public class JavassistTest {
    public static void main(String[] args) throws NotFoundException, CannotCompileException, IllegalAccessException, InstantiationException, IOException {
        ClassPool cp = ClassPool.getDefault();
        CtClass cc = cp.get("meituan.bytecode.javassist.Base");
        CtMethod m = cc.getDeclaredMethod("process");
        m.insertBefore("{ System.out.println(\"start\"); }");
        m.insertAfter("{ System.out.println(\"end\"); }");
        Class c = cc.toClass();
        cc.writeFile("/Users/zen/projects");
        Base h = (Base)c.newInstance();
        h.process();
    }
}
```

## 运行时类重载

如果我们在一个 JVM 中，先加载了一个类，然后又对其进行字节码增强并重新加载会发生什么呢？模拟这种情况，只需要我们在上文中 Javassist 的 Demo 中 main()方法的第一行添加 Base b=new Base()，即在增强前就先让 JVM 加载 Base 类，然后在执行到 c.toClass()方法时会抛出错误，如下图 20 所示。跟进 c.toClass()方法中，我们会发现它是在最后调用了 ClassLoader 的 native 方法 defineClass()时报错。也就是说，JVM 是不允许在运行时动态重载一个类的。

![aop3.png](/docs/jvm/aop3.png)
图 20 运行时重复 load 类的错误信息

显然，如果只能在类加载前对类进行强化，那字节码增强技术的使用场景就变得很窄了。我们期望的效果是：在一个持续运行并已经加载了所有类的 JVM 中，还能利用字节码增强技术对其中的类行为做替换并重新加载。为了模拟这种情况，我们将 Base 类做改写，在其中编写 main 方法，每五秒调用一次 process()方法，在 process()方法中输出一行“process”。

我们的目的就是，在 JVM 运行中的时候，将 process()方法做替换，在其前后分别打印“start”和“end”。也就是在运行中时，每五秒打印的内容由"process"变为打印"start process end"。那如何解决 JVM 不允许运行时重加载类信息的问题呢？为了达到这个目的，我们接下来一一来介绍需要借助的 Java 类库。

```java
import java.lang.management.ManagementFactory;

public class Base {
    public static void main(String[] args) {
        String name = ManagementFactory.getRuntimeMXBean().getName();
        String s = name.split("@")[0];
        //打印当前Pid
        System.out.println("pid:"+s);
        while (true) {
            try {
                Thread.sleep(5000L);
            } catch (Exception e) {
                break;
            }
            process();
        }
    }

    public static void process() {
        System.out.println("process");
    }
}
```

### Instrument

instrument 是 JVM 提供的一个可以修改已加载类的类库，专门为 Java 语言编写的插桩服务提供支持。它需要依赖 JVMTI 的 Attach API 机制实现，JVMTI 这一部分，我们将在下一小节进行介绍。在 JDK 1.6 以前，instrument 只能在 JVM 刚启动开始加载类时生效，而在 JDK 1.6 之后，instrument 支持了在运行时对类定义的修改。要使用 instrument 的类修改功能，我们需要实现它提供的 ClassFileTransformer 接口，定义一个类文件转换器。接口中的 transform()方法会在类文件被加载时调用，而在 transform 方法里，我们可以利用上文中的 ASM 或 Javassist 对传入的字节码进行改写或替换，生成新的字节码数组后返回。

我们定义一个实现了 ClassFileTransformer 接口的类 TestTransformer，依然在其中利用 Javassist 对 Base 类中的 process()方法进行增强，在前后分别打印“start”和“end”，代码如下：

```java
import java.lang.instrument.ClassFileTransformer;

public class TestTransformer implements ClassFileTransformer {
    @Override
    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) {
        System.out.println("Transforming " + className);
        try {
            ClassPool cp = ClassPool.getDefault();
            CtClass cc = cp.get("meituan.bytecode.jvmti.Base");
            CtMethod m = cc.getDeclaredMethod("process");
            m.insertBefore("{ System.out.println(\"start\"); }");
            m.insertAfter("{ System.out.println(\"end\"); }");
            return cc.toBytecode();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
```

现在有了 Transformer，那么它要如何注入到正在运行的 JVM 呢？还需要定义一个 Agent，借助 Agent 的能力将 Instrument 注入到 JVM 中。我们将在下一小节介绍 Agent，现在要介绍的是 Agent 中用到的另一个类 Instrumentation。在 JDK 1.6 之后，Instrumentation 可以做启动后的 Instrument、本地代码（Native Code）的 Instrument，以及动态改变 Classpath 等等。我们可以向 Instrumentation 中添加上文中定义的 Transformer，并指定要被重加载的类，代码如下所示。这样，当 Agent 被 Attach 到一个 JVM 中时，就会执行类字节码替换并重载入 JVM 的操作。

```java
import java.lang.instrument.Instrumentation;

public class TestAgent {
    public static void agentmain(String args, Instrumentation inst) {
        //指定我们自己定义的Transformer，在其中利用Javassist做字节码替换
        inst.addTransformer(new TestTransformer(), true);
        try {
            //重定义类并载入新的字节码
            inst.retransformClasses(Base.class);
            System.out.println("Agent Load Done.");
        } catch (Exception e) {
            System.out.println("agent load failed!");
        }
    }
}
```

对于启动是加载如下：

```java
public class TestAgent {
    public static void premain(String args, Instrumentation inst) {
        //指定我们自己定义的Transformer，在其中利用Javassist做字节码替换
        inst.addTransformer(new TestTransformer());
    }
}
```

将 TestAgent 类打成一个包含 MANIFEST.MF 的 jar 包，并在启动参数中添加`-javaagent:TestAgent.jar`,其中 MANIFEST.MF 文件中将 Premain-Class 属性指定为 TestAgent 的全限定名，如下所示；

```txt
 <plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-jar-plugin</artifactId>
    <version>2.4</version>
    <configuration>
        <archive>
            <manifestEntries>
                <Premain-Class>xx.xx.xx.TestAgent</Premain-Class>
                <Boot-Class-Path>javassist-3.27.0-GA.jar</Boot-Class-Path>
            </manifestEntries>
        </archive>
    </configuration>
</plugin>
```

### JVMTI & Agent & Attach API

上一小节中，我们给出了 Agent 类的代码，追根溯源需要先介绍 JPDA（Java Platform Debugger Architecture）。如果 JVM 启动时开启了 JPDA，那么类是允许被重新加载的。在这种情况下，已被加载的旧版本类信息可以被卸载，然后重新加载新版本的类。正如 JDPA 名称中的 Debugger，JDPA 其实是一套用于调试 Java 程序的标准，任何 JDK 都必须实现该标准。

JPDA 定义了一整套完整的体系，它将调试体系分为三部分，并规定了三者之间的通信接口。三部分由低到高分别是 Java 虚拟机工具接口（JVMTI），Java 调试协议（JDWP）以及 Java 调试接口（JDI），三者之间的关系如下图所示：

![aop4.png](/docs/jvm/aop4.png)
图 21 JPDA

现在回到正题，我们可以借助 JVMTI 的一部分能力，帮助动态重载类信息。JVM TI（JVM TOOL INTERFACE，JVM 工具接口,${JAVA_HOME}/lib/tools.jar）是 JVM 提供的一套对 JVM 进行操作的工具接口。通过 JVMTI，可以实现对 JVM 的多种操作，它通过接口注册各种事件勾子，在 JVM 事件触发时，同时触发预定义的勾子，以实现对各个 JVM 事件的响应，事件包括类文件加载、异常产生与捕获、线程启动和结束、进入和退出临界区、成员变量修改、GC 开始和结束、方法调用进入和退出、临界区竞争与等待、VM 启动与退出等等。

而 Agent 就是 JVMTI 的一种实现，Agent 有两种启动方式，一是随 Java 进程启动而启动，经常见到的 java -agentlib 就是这种方式；二是运行时载入，通过 attach API，将模块（jar 包）动态地 Attach 到指定进程 id 的 Java 进程内。

Attach API 的作用是提供 JVM 进程间通信的能力，比如说我们为了让另外一个 JVM 进程把线上服务的线程 Dump 出来，会运行 jstack 或 jmap 的进程，并传递 pid 的参数，告诉它要对哪个进程进行线程 Dump，这就是 Attach API 做的事情。在下面，我们将通过 Attach API 的 loadAgent()方法，将打包好的 Agent jar 包动态 Attach 到目标 JVM 上。具体实现起来的步骤如下：

- 定义 Agent，并在其中实现 AgentMain 方法，如上一小节中定义的代码块 7 中的 TestAgent 类；
- 然后将 TestAgent 类打成一个包含 MANIFEST.MF 的 jar 包，其中 MANIFEST.MF 文件中将 Agent-Class 属性指定为 TestAgent 的全限定名，如下所示；

```txt
 <plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-jar-plugin</artifactId>
    <version>2.4</version>
    <configuration>
        <archive>
            <manifestEntries>
                <Agent-Class>xx.xx.xx.TestAgent</Agent-Class>
                <Can-Redefine-Classes>true</Can-Redefine-Classes>
                <Can-Retransform-Classes>true</Can-Retransform-Classes>
                <Boot-Class-Path>javassist-3.27.0-GA.jar</Boot-Class-Path>
            </manifestEntries>
        </archive>
    </configuration>
</plugin>
```

- 最后利用 Attach API，将我们打包好的 jar 包 Attach 到指定的 JVM pid 上，代码如下：

```java
//${JAVA_HOME}/lib/tools.jar
import com.sun.tools.attach.VirtualMachine;

public class Attacher {
    public static void main(String[] args) throws AttachNotSupportedException, IOException, AgentLoadException, AgentInitializationException {
        // 传入目标 JVM pid
        VirtualMachine vm = VirtualMachine.attach("39333");
        vm.loadAgent("/Users/zen/operation_server_jar/operation-server.jar");
    }
}
```

- 由于在 MANIFEST.MF 中指定了 Agent-Class，所以在 Attach 后，目标 JVM 在运行时会走到 TestAgent 类中定义的 agentmain()方法，而在这个方法中，我们利用 Instrumentation，将指定类的字节码通过定义的类转化器 TestTransformer 做了 Base 类的字节码替换（通过 javassist），并完成了类的重新加载。由此，我们达成了“在 JVM 运行时，改变类的字节码并重新载入类信息”的目的。

以下为运行时重新载入类的效果：先运行 Base 中的 main()方法，启动一个 JVM，可以在控制台看到每隔五秒输出一次"process"。接着执行 Attacher 中的 main()方法，并将上一个 JVM 的 pid 传入。此时回到上一个 main()方法的控制台，可以看到现在每隔五秒输出"process"前后会分别输出"start"和"end"，也就是说完成了运行时的字节码增强，并重新载入了这个类。

![aop5.png](/docs/jvm/aop5.png)
图 23 运行时重载入类的效果

### 使用场景

至此，字节码增强技术的可使用范围就不再局限于 JVM 加载类前了。通过上述几个类库，我们可以在运行时对 JVM 中的类进行修改并重载了。通过这种手段，可以做的事情就变得很多了：

- 热部署：不部署服务而对线上服务做修改，可以做打点、增加日志等操作。
- Mock：测试时候对某些服务做 Mock。
- 性能诊断工具：比如 bTrace 就是利用 Instrument，实现无侵入地跟踪一个正在运行的 JVM，监控到类和方法级别的状态信息。

## 重写类加载器

通过类加载器读取字节流，在将字节流转成 Class 对象之前利用字节码增强工具对类进行增强(上文的某些方式)，之后将增强之后的字节流重新解析成 Class 对象。

## JDK 动态代理

利用拦截器（必须实现 InvocationHandler）加上反射机制生成一个代理接口的匿名类，在调用具体方法前调用 InvokeHandler 来处理，只能对实现了接口的类生成代理，而不能针对类。

```java
public class DynamicProxy<T> {
    private T target;

    public DynamicProxy(T tObj){
        this.target = tObj;
    }

    public T getProxy(){
        Object proxy = Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),
            new InvocationHandler() {
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    long cost = System.currentTimeMillis();
                    Object result = method.invoke(target, args);
                    cost = System.currentTimeMillis() - cost;
                    System.out.println("method "+ method.getName() + " cost time "+cost);
                    return result;
                }
            });
        return (T)proxy;
    }
}

public class Main {

    public static void main(String[] args) throws Exception {
        NameService nameService = new DynamicProxy<NameService>(new NameServiceImpl()).getProxy();
        nameService.printName("tiang");
    }
}
/**输出
tiang
method printName cost time 1001
**/
```

## cglib 代理

利用 ASM 框架，对代理对象类生成的 class 文件加载进来，通过修改其字节码生成子类来处理,采用的是继承，所以该类或方法最好不要生成 final，对于 final 类或方法，是无法继承的。

```java
public class Main {
    static class Test{
        public void test(){
            System.out.println("test");
            try {
                Thread.sleep(1000L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) throws Exception {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(Test.class);
        enhancer.setCallback(new MethodInterceptor() {
            @Override
            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy)
                throws Throwable {
                long cost = System.currentTimeMillis();
                Object result = methodProxy.invokeSuper(o, objects);
                System.out.println("cost time :" + (System.currentTimeMillis() - cost));
                return result;
            }
        });
        Test test = (Test)enhancer.create();
        test.test();
    }
}
/**输出
test
cost time :1012
**/
```

## javassist 在 SpringBoot 环境下找不到类的问题

[原文](https://blog.csdn.net/protobe/article/details/93625240)

关于类装载器，具体的这里不展开，只简单说一下要点：

- 类装载器（以下简称 CL）负责将类装入虚拟机
- java 内置三种 CL：application 应用、extension 扩展和 bootstrap 引导
  - 引导 CL：负责装载 JDK 内部类，包括 rt.jar 和 jre/lib/目录下其他核心库中的类，它也是所有装载器的爸爸
  - 扩展 CL：负责装载标准核心 java 类的扩展类（lib/ext 等），它是引导 CL 的儿子
  - 应用 CL：或称系统 CL，负责装载所有应用级的类，它是扩展 CL 的儿子
- 委托模型：要装载某个类时，CL 会先委托给自己的爸爸，最后才会由自己来装载
- 自定义 CL：当内置的 CL 无法满足需求时，可以自定义 CL，例如 SpringBoot 就有自己的 CL，专门用来从它那个结构特殊的 jar 包中装载类
- 类的可见性：儿子装载的类可以看到爸爸装载的类，但反过来不行——爸爸装载的类看不到儿子装载的类（可怜天下父母心）

好了，那么上面问题的根源，就是 javassist 想要找的这个类，其实是放在 SpringBoot 那个特殊的包里，而它用的装载器（应用 CL）却只会在类路径里（-classpth）里去找一圈，结果当然是找不到。

### 获取 SpringBoot 的类装载器

这个装载器本身是由应用 CL 来装载的，所以 javassist 默认情况下就能看到。

```java
public class CustomTransFormer implements ClassFileTransformer {

    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined,
                            ProtectionDomain protectionDomain, byte[] classfileBuffer) {
        try {
            if (className == null || !className.equals("org/springframework/boot/loader/LaunchedURLClassLoader")) {
                return classfileBuffer;
            }
            System.out.println("********Transforming " + className);
            ClassPool classPool = ClassPool.getDefault();
            CtClass ctClass = classPool.makeClass(new java.io.ByteArrayInputStream(classfileBuffer));
            CtConstructor[] ctConstructors = ctClass.getDeclaredConstructors();
            ctConstructors[0].insertAfter("com.zhds.jdbc.extend.CustomTransFormer.modifyClass(this);");
            return ctClass.toBytecode();
        } catch (Exception e) {
            System.err.println("Could not instrument  " + className + ",  exception : " + e);
        }
        return classfileBuffer;
    }

    public static void modifyClass(ClassLoader classLoader) {
        try {
            ClassPool classPool = ClassPool.getDefault();
            classPool.appendClassPath(new LoaderClassPath(classLoader));
            CtClass ctClass = classPool.get("org.springframework.web.servlet.FrameworkServlet");
            System.out.println("********Transforming " + ctClass.getPackageName());
            CtMethod ctMethod = ctClass.getDeclaredMethod("service");
            ctMethod.insertAfter("System.out.println(\" request from:\" +request.getRemoteAddr()+\",principle:\"+  request.getUserPrincipal().getName() +\",sessionId:\"+request.getCookies()[0].getValue() +\",at:\"+ System.currentTimeMillis());");
            ctClass.toClass(classLoader, ctClass.getClass().getProtectionDomain());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

## 参考

- [Java 字节码增强探秘](https://segmentfault.com/a/1190000020345321?utm_source=tag-newest)
- [java 类增强机制](https://blog.csdn.net/u012094957/article/details/109464760)
- [java.lang.instrument 使用](https://www.cnblogs.com/wade-luffy/p/6078301.html)
- [Oracle:The class File Format](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html)
- [Oracle:The Java Virtual Machine Instruction Set](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html)
- [javassist tutorial](http://www.javassist.org/tutorial/tutorial.html)
- [JVM Tool Interface - Version 1.2](https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html)
