## du

disk usage,是通过搜索文件来计算每个文件的大小然后累加，du 能看到的文件只是一些当前存在的，没有被删除的。他计算的大小就是当前他认为存在的所有文件大小的累加和。

```bash
du -sh  #查看当前目录总共占的容量，不单独列出各子项占用的容量
du -sh file  #查看文件file的大小
du -ah --max-depth=1  #查看当前目录下一级子文件和子目录占用的磁盘容量
```

:::note

- s 即 summarize，即仅输出总大小
- a 表示显示目录下所有的文件和文件夹（不含子目录）
- h 表示以以 K，M，G 为单位，提高信息的可读性
- max-depth 表示目录的深度。

:::

### 按照空间大小排序

`du|sort -nr|more`

:::info

sort:

- -n, --numeric-sort compare according to string numerical value
- -h, --human-numeric-sort compare human readable numbers (e.g., 2K 1G)

:::

## df

disk free，通过文件系统来快速获取空间大小的信息，当我们删除一个文件的时候，这个文件不是马上就在文件系统当中消失了，而是暂时消失了，当所有程序都不用时，才会根据 OS 的规则释放掉已经删除的文件， df 记录的是通过文件系统获取到的文件的大小，他比 du 强的地方就是能够看到已经删除的文件，而且计算大小的时候，把这一部分的空间也加上了，更精确了。

```bash
df #显示磁盘使用情况
df -T #列出文件系统的类型
df -h #以更易读的方式显示目前磁盘空间和使用情况
```

:::caution
当文件系统也确定删除了该文件后，这时候 du 与 df 就一致了
:::

## 文件系统满的处理

常规的步骤是：确认文件系统使用率、找出大文件（目录）、清理。

### 查看文件系统利用率

df 命令初步定位一下是否有利用率(Use%)为 100%或可用量（Avail）几乎为 0 的的文件系统。如果只看某个文件或目录所在的文件系统，则可以跟上路径名，比如`df /home`只会报告/home 所在的文件系统的情况。

### 找出大文件（目录）

找出大文件可以通过`du`命令完成。du 命令默认是递归输出所有子目录的大小，如果子目录很多层，会让人眼花缭乱，并不实用，使用`du -sh *`输出当前目录各子目录或文件的大小。递归的使用`du -sh *`查看，直到找出需要删除的大文件。

### 删除

删除就很容易了，直接 rm 或使用 find 命令根据条件 rm。

### 删除后空间不释放

某些特殊情况，会出现删除后空间不释放的问题。更诡异的是明明在文件系统根目录使用`du -sh .`查看总使用大小，竟然和`df -h`显示的使用大小不一致。这很可能是出现了某个进程占用了该文件。在这种情况下，即便删除了文件，文件系统也不会释放。具体验证的方法就是使用`lsof | grep "(deleted)"`查看是否存在你删除的文件，并查看其进程 ID，根据进程 ID 找到对应进程，尝试重启该进程。

:::caution 注意
出现这种诡异的现象，是因为 Linux 下文件系统使用 inode 进行管理。对进程来说，对文件的引用并不是通过路径名实现，所有的路径名都要转换成一个 inode 的结点 id，路径名只不过是提供给“用户”的概念。 正式基于此，Linux 下竟然可以在进程使用的时候，对占用的文件进行重命名甚至删除操作。因为，进程根本不关心路径名！
:::

:::info 简化

1. 使用`df`确定是否存在文件系统满
2. 使用`du -sh *`逐级搜索大文件或目录
3. 使用`rm -rf`删除

- 如果发现文件删除后，`df`没有明显的看到文件系统释放，使用`lsof | grep "(deleted)"`查看是否存在删除的文件仍然被某个进程使用

:::
