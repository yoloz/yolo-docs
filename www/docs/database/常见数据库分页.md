## mysql

```sql
SELECT
    column1,column2,...
FROM
    table
LIMIT offset , count;
```

> - offset 参数指定要返回的第一行的偏移量（第一行的偏移量为 0);
> - count 指定要返回的最大行数;
> - 在使用 limit 的时候不指定 order by， 那么每次的结果可能是不确定的;

## pgsql

```sql
SELECT column1, column2, columnN
FROM table_name
LIMIT [count]
-- LIMIT 子句与 OFFSET 子句一起使用
SELECT column1, column2, columnN
FROM table_name
LIMIT [count] OFFSET [offset]
```

> - offset 参数指定要返回的第一行的偏移量（第一行的偏移量为 0);
> - count 指定要返回的最大行数;
> - 在使用 limit 的时候不指定 order by， 那么每次的结果可能是不确定的;

## oracle

```sql
--  查询前10行记录
SELECT t1.* FROM XXX t1 WHERE ROWNUM <= 10;

--  查询从11行到20行的记录
SELECT * FROM XXX WHERE ROWNUM < 21 MINUS SELECT * FROM XXX WHERE ROWNUM < 11;
或者
-- rownum不可以以任何表的名称作为前缀， 因此子查询中的rownum必须起别名
SELECT * FROM (SELECT ROWNUM NO, t1.* FROM XXX t1) t2 WHERE t2.NO > 10 AND t2.NO < 21;

-- select * from XXX where rownum > 10 and rownum < 21 会返回空结果集

-- Oracle >=12 Syntax(rownum新老版本都可用):
SELECT column_name(s)
FROM table_name
ORDER BY column_name(s)
FETCH FIRST count ROWS ONLY;
```

> - rownum 是根据 sql 查询出的结果给每行分配一个逻辑编号；
> - rowid 是物理结构上的，在每条记录 insert 到数据库中时生成，查询的时候必须起别名，不然不会显示;

## mssql

如果版本支持，选择版本要求越高的方式效率越好。

### top 嵌套查询

简单的来说就是,我们需要第 5-6 条数据,我们先查前 前 5 条 id 为一个集合,再从原表中取 id 不在这个集合中的前 5 条

```sql
-- 取第一页
select top 5 * from [mydb].[dbo].[user] where ID not in (select top 0 ID from [mydb].[dbo].[user]);
-- 取第二页
select top 5 * from [mydb].[dbo].[user] where ID not in (select top 5 ID from [mydb].[dbo].[user]);
-- 这种分页方式的通用模板如下
-- 原始SQL:
select * from [mydb].[dbo].[user] where name like 'name%'
-- 拼接分页后：
select top 5 * from (
-- 原始SQL
) AS A where ID not in (select top 5 ID from [mydb].[dbo].[user]);
```

> 可以添加`order by`和条件;
>
> 内层的 top 后面相当于起始值，计算方式为`(页号-1)*页大小`

### ROW_NUMBER() OVER()

通过 `ROW_NUMBER()`生成序号列,根据序号列取需要数据,`over`函数必须有。

```sql
-- 取第一页数据
select * from (select *, ROW_NUMBER() OVER(Order by ID ) AS RowId from [mydb].[dbo].[user]) as b where RowId between 1 and 5;
-- 取第二页数据
select * from (select *, ROW_NUMBER() OVER(Order by ID ) AS RowId from [mydb].[dbo].[user]) as b where RowId between 6 and 10;

-- 这种方式的通用写法如下: 原来SQL不能带order by ，但是可以带条件。
-- 原始SQL如下
select * from [mydb].[dbo].[user] where name like 'name%'
-- 拼接分页模板如下
select * from (
    select *, ROW_NUMBER() OVER(Order by ID ) AS RowId from (
            -- 原始SQL
        ) AS A
) as B
where RowId between 1 and 5;
```

> 支持 SqlServer 2005 版本以上;
>
> 不指定 order by， 那么每次的结果可能是不确定的;
>
> RowId BETWEEN `(当前页数-1)*页大小+1` and `页数*页大小`,而且包含起始值与结束值。

### ROW_NUMBER() + top

```sql
-- 取第一页
select top (5) * from (select *, ROW_NUMBER() OVER(Order by ID ) AS RowId from [mydb].[dbo].[user]) as A where A.RowId>0;
-- 取第二页
select top (5) * from (select *, ROW_NUMBER() OVER(Order by ID ) AS RowId from [mydb].[dbo].[user]) as A where A.RowId>5;
-- 这种分页方式的通用模板如下
-- 原始SQL:
select * from [mydb].[dbo].[user] where name like 'name%'
-- 拼接分页后：
select top (5) * from (
    select *, ROW_NUMBER() OVER(Order by ID ) AS RowId from (
-- 原始SQL
        ) as A
) as B where B.RowId>5;
```

> 第一个 top 里面的值 相当于 `页大小`，第二个`rowID>起始值`，起始值计算方式为`(页号-1）*页大小`

### offset fetch

offset x rows（：跳过前 x 行） fetch next y rows（：取之后的 y 行）

```sql
-- 取第一页
select * from [mydb].[dbo].[user]   order by ID offset 0 rows fetch next 5 rows only;
-- 取第二页
select * from [mydb].[dbo].[user]   order by ID offset 5 rows fetch next 5 rows only;
```

> SqlServer 2012 版本以上;
>
> 不指定 order by， 那么每次的结果可能是不确定的;
>
> offset `页号*页大小` rows fetch next `页大小` rows only

## db2

```sql
SELECT select_list
FROM table_name
ORDER BY sort_expression
LIMIT count [OFFSET offset];
-- 简化用法同mysql
SELECT select_list
FROM table_name
ORDER BY sort_expression
LIMIT count，offset;
```

> - offset 参数指定要返回的第一行的偏移量（第一行的偏移量为 0);
> - count 指定要返回的最大行数;
> - 在使用 limit 的时候不指定 order by， 那么每次的结果可能是不确定的;

## vertica

同 db2

> When a SELECT statement specifies both LIMIT and OFFSET, Vertica first processes the OFFSET statement, and then applies the LIMIT statement to the remaining rows.
